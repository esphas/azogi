<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Azogi is a charset-based azogi-style random identifier generator.">
    <link rel="icon" type="image/png" href="favicon.png">
    <title>Azogi</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        font-size: 16px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      }
      #root {
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #output {
        margin: 0;
        padding: 0;
        font-size: 8rem;
        max-width: 80%;
        min-height: 11.2rem;
        line-height: 11.2rem;
        text-align: center;
        word-wrap: break-word;
        overflow: hidden;
      }
      #input {
        min-width: 8rem;
        max-width: 80%;
        margin: 0;
        padding: 8px;
        font-size: 2rem;
        min-height: 2.8rem;
        line-height: 2.8rem;
        text-align: center;
        border: grey solid;
        overflow: hidden;
      }
      .normal {
        color: black;
      }
      .keyword {
        color: green;
      }
      .warning {
        color: red;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div id="output">Azogi</div>
      <div id="input"></div>
    </div>
    <script>
      (function() {
        // initialize
        var output = document.querySelector('#output');
        var input = document.querySelector('#input');
        input.setAttribute('contentEditable', 'true');
        input.setAttribute('autocomplete', 'off');
        input.setAttribute('autocorrect', 'off');
        input.setAttribute('autocapitalize', 'off');
        input.setAttribute('spellcheck', 'false');
        // azogi
        function azogi(pattern, ...allCharsets) {
          var charsets = Object.assign({}, ...allCharsets);
          return Array.from(pattern).map((key) => {
            var charset = charsets[key];
            if (charset == null) {
              return key;
            }
            charset = Array.from(charset);
            return charset[Math.floor(Math.random() * charset.length)];
          }).join('');
        }
        var charsetPresets = {
          v: 'aeiou',
          c: 'bcdfghjklmnpqrstvwxyz',
        };
        /**
         * 1. read current state
         *   a) read text segments from input field
         *   b) find selection anchor and focus
         *   c) load charsets
         * 2. parse infomation
         *   a) text segments -> string
         *   b) re-calculate selection anchor and focus
         * 3. render and restore selection
         * 4. process input to produce output
         */
        function updateInput() {
          function getTextSegments(element) {
            var segments = [];
            Array.from(element.childNodes).forEach((node) => {
              if (node.nodeType === Node.TEXT_NODE) {
                segments.push({ text: node.nodeValue, node });
              } else if (node.nodeType === Node.ELEMENT_NODE) {
                segments.splice(segments.length, 0, ...getTextSegments(node));
              }
            });
            return segments;
          }
          function renderText(text, charsets) {
            function getType(char) {
              if (charsets.hasOwnProperty(char)) {
                return 'keyword';
              }
              if (char === char.toLowerCase()) {
                return 'warning';
              }
              return 'normal';
            }
            var units = Array.from(text).map((char) => {
              return { char, type: getType(char) }
            });
            var mergedUnits = [];
            var char = null;
            var type = null;
            units.forEach((unit) => {
              if (type == null) {
                char = unit.char;
                type = unit.type;
              } else if (type === unit.type) {
                char += unit.char;
              } else {
                mergedUnits.push({ char, type });
                char = unit.char;
                type = unit.type;
              }
            });
            if (type != null) {
              mergedUnits.push({ char, type });
            }
            var nodes = mergedUnits.map((unit) => {
              var node = document.createElement('span');
              node.classList.add(unit.type);
              node.appendChild(document.createTextNode(unit.char));
              return node;
            });
            return nodes;
          }
          // 1
          var segments = getTextSegments(input);
          var selection = window.getSelection();
          var charsets = Object.assign({}, charsetPresets);
          // 2
          var pattern = segments.map((segment) => segment.text).join('').replace(' ', '\u00A0');
          var absoluteAnchorIndex = null;
          var absoluteFocusIndex = null;
          var currentIndex = 0;
          segments.forEach((segment) => {
            if (segment.node === selection.anchorNode) {
              absoluteAnchorIndex = currentIndex + selection.anchorOffset;
            }
            if (segment.node === selection.focusNode) {
              absoluteFocusIndex = currentIndex + selection.focusOffset;
            }
            currentIndex += segment.text.length;
          });
          // 3
          var textNodes = renderText(pattern, charsets);
          while (input.firstChild) {
            input.removeChild(input.firstChild);
          }
          textNodes.forEach((node) => {
            input.appendChild(node);
          });
          var anchorNode = input;
          var anchorIndex = 0;
          var focusNode = input;
          var focusIndex = 0;
          currentIndex = 0;
          segments = getTextSegments(input);
          segments.forEach((segment) => {
            var start = currentIndex;
            var end = currentIndex + segment.text.length;
            if (start <= absoluteAnchorIndex && absoluteAnchorIndex <= end) {
              anchorNode = segment.node;
              anchorIndex = absoluteAnchorIndex - start;
            }
            if (start <= absoluteFocusIndex && absoluteFocusIndex <= end) {
              focusNode = segment.node;
              focusIndex = absoluteFocusIndex - start;
            }
            currentIndex += segment.text.length;
          });
          selection.setBaseAndExtent(anchorNode, anchorIndex, focusNode, focusIndex);
          // 4
          var results = azogi(pattern, charsets);
          if (results === '') {
            results = 'Azogi';
          }
          results = results[0].toUpperCase() + results.slice(1).toLowerCase();
          output.textContent = results;
        }
        input.addEventListener('input', updateInput);
      })();
    </script>
  </body>
</html>
